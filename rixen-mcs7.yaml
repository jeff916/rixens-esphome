esphome:
  name: rixen-mcs7
  friendly_name: Rixen MCS7
  comment: Rixen MCS7 System Canbus Interface
  project:
    name: rixen.canbus
    version: 1.3.1

esp32:
  variant: ESP32
#  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: "eErA9p/hVXg9B9UW8jgbllmZo4GROFEqecAsacIs42U="
#  reboot_timeout: 0s # disable api reboot for bench test. Default 15min

ota:
  - platform: esphome
    password: !secret esphome_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # manual IP
  manual_ip:
    static_ip: 192.168.50.37
    gateway: 192.168.50.1
    subnet: 255.255.255.0

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Rixen-Mcs7 Fallback Hotspot"
    password: !secret hotspot_password

captive_portal:

#web_server:
#  port: 80
  
#Red LED is status led
status_led:
  pin:
    number: GPIO02
    inverted: true
    ignore_strapping_warning: true

# -------------------------------------------------------
# GLOBALS
# -------------------------------------------------------
globals:
  # Prevent overlapping updates
  - id: update_lock
    type: bool
    initial_value: "false"

  # Buffer for target temperature updates from CAN or HA
  - id: new_target_temp
    type: float
    initial_value: "20.0"

  - id: current_target_f
    type: float
    restore_value: yes
    initial_value: "68.0"

  - id: block_heater_updates_until
    type: uint32_t
    restore_value: no
    initial_value: "0"

# -------------------------------------------------------
# SCRIPT: Serializes all thermostat updates
# -------------------------------------------------------
script:
  - id: safe_update_target
    mode: queued      # <<< prevents race conditions
    then:
      - lambda: |-
          //if (id(update_lock)) return;
          id(update_lock) = true;

          // Race condition protection: ignore for 2s after sending setpoint
          if (id(block_heater_updates_until) > millis()) {
            ESP_LOGI("heater", "Ignoring heater echo: %.1f°F", id(new_target_temp));
            return;
          }

          ESP_LOGI("heater", "Update heater target: New %f Current %f", id(new_target_temp), id(this_thermostat).target_temperature);
          // commit new target temp
          if(id(new_target_temp) != id(this_thermostat).target_temperature) {
          
            // Create climate call
            auto call = id(this_thermostat).make_call();
            call.set_target_temperature(id(new_target_temp));
            call.perform();
          }

          id(update_lock) = false;

# -------------------------------------------------------
# Rixen CanBus Interface
# -------------------------------------------------------
canbus:
  - platform: esp32_can
    tx_pin: GPIO25
    rx_pin: GPIO26
    can_id: 0x788
    bit_rate: 250KBPS
    use_extended_id: false
    on_frame:
      # HC_Diag2
      - can_id: 0x726
        then:
#          - lambda: |-
#              ESP_LOGI("HC_Diag2", "Data: %02X %02X %02X", x[0], x[1], x[2] );

          - lambda: |-
              if(x.size() > 0) {
                int leftmost_byte, rightmost_byte;

                // glycol inlet temp
                rightmost_byte = (x[0] & 0x00FF) >> 0; 
                leftmost_byte = (x[1] & 0x00FF) << 8;
                id(inlet_temp).publish_state( int(leftmost_byte | rightmost_byte) * .01 );

                //ESP_LOGI("inlet_temp", "hex_string: %02X%02X right_left %02X%02X Float %f %f", x[1], x[0], rightmost_byte, leftmost_byte, strtol(hex_string, NULL, 16) * .01, result );

                // glycol outlet temp
                rightmost_byte = (x[2] & 0x00FF) >> 0; 
                leftmost_byte = (x[3] & 0x00FF) << 8;
                id(outlet_temp).publish_state( int(leftmost_byte | rightmost_byte) * .01 );
                
                // Flame Sensor temp
                rightmost_byte = (x[4] & 0x00FF) >> 0; 
                leftmost_byte = (x[5] & 0x00FF) << 8;
                id(FlameSensor).publish_state( int(leftmost_byte | rightmost_byte) * .01 );

                // voltage
                rightmost_byte = (x[6] & 0x00FF) >> 0; 
                leftmost_byte = (x[7] & 0x00FF) << 8;
                id(voltage).publish_state( int(leftmost_byte | rightmost_byte) * .1 );
              }

      # HC_Diag       
      - can_id: 0x725
        then:
#          - lambda: |-
#              if(x.size() > 0) {
#                ESP_LOGI("HC_Diag", "hex is - %x %x %x %x %x %x %x %x", x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7]);
#              }

          - lambda: |-
              if(x.size() > 0) {
                char hex_string[6];
                long leftmost_byte, middle_byte, rightmost_byte;

                // heater Runtime
                rightmost_byte = (x[0] & 0x00FF) >> 0; 
                middle_byte = (x[1] & 0x00FF) << 8;
                leftmost_byte = (x[2] & 0x00FF) << 16;
                id(heater_runtime).publish_state( long(leftmost_byte | middle_byte | rightmost_byte) );

                // heater fan
                rightmost_byte = (x[4] & 0x00FF) >> 0; 
                leftmost_byte = (x[5] & 0x00FF) << 8;
                id(heater_fan).publish_state( int(leftmost_byte | rightmost_byte) );

                // heater glow
                rightmost_byte = (x[6] & 0x00FF) >> 0; 
                leftmost_byte = (x[7] & 0x00FF) << 8;
                id(heater_glow).publish_state( int(leftmost_byte | rightmost_byte) * .1 );
                
                // heater fuel
                id(heater_fuel).publish_state( int(x[3]) * .1 );
              }

      # bi-directional control - if settings changed on Rixen's interface, update home assistant
      # HC_Status
      - can_id: 0x724
        then:
          - lambda: |-
              if(x.size() > 0) {
                char hex2_string[4];
                int leftmost_byte, rightmost_byte;

                //leftmost_byte = (x[3] & 0x00FF) << 8;
                //sprintf(hex2_string, "%02X%02X", x[3], x[2]);
                //ESP_LOGI("HC_Status", "Setpoint_Temp:%02X%02X %f Flags: %02X", x[3], x[2], int(leftmost_byte | x[2]) *.1, x[6] );

                //ambient temperature
                //char hex_string[6];
                leftmost_byte = (x[1] & 0x00FF) << 8;
                id(ambient_temperature).publish_state( int(leftmost_byte | x[0]) * .1 );

                //Setpoint temperature
                float sp;
                leftmost_byte = (x[3] & 0x00FF) << 8;
                sp = (leftmost_byte | x[2]) * .1;
                //id(new_target_temp) = sp;

                //id(setpoint_temperature).publish_state( sp );
                //id(target_temperature).publish_state( sp );
                ESP_LOGI("HC_Status", "CAN Setpoint_Temp:%f", sp);
                // Race condition protection: ignore for 2s after sending setpoint
                if (id(block_heater_updates_until) > millis()) {
                  ESP_LOGI("heater", "Ignoring heater echo: %f", sp);
                }
                else {
                  // commit new target temp
                  if(sp != id(this_thermostat).target_temperature) {
                    ESP_LOGI("heater", "Update heater target: New %f Current %f", sp, id(this_thermostat).target_temperature);
                    // Create climate call
                    auto call = id(this_thermostat).make_call();
                    call.set_target_temperature(sp);
                    call.perform();
                  }
                }

                //Relative Humidity
                id(relative_humidity).publish_state( int(x[7]) * .1 );

                //Fan On
                id(FanOn_id).publish_state( (x[6] & 0b00000001) != 0 );

                //Heat On
                id(HeatOn_id).publish_state( (x[6] & 0b00000010) != 0 );

                //Pump On
                id(PumpOn_id).publish_state( (x[6] & 0b00000100) != 0 );

                //furnace selected
                bool b = ((x[6] & 0b00001000) != 0);
                bool c = id(furnace_id).state;

                if (b != c) {
                  if (b) {
                    id(this_thermostat).mode = climate::CLIMATE_MODE_HEAT;
                  }
                  else {
                    id(this_thermostat).mode = climate::CLIMATE_MODE_OFF;
                  }
                  id(furnace_id).publish_state( b );
                }
                //electric selected
                id(electric_id).publish_state( (x[6] & 0b00010000) != 0 );

                //Constant Heat (Hot Water) selected
                id(hot_water_id).publish_state( (x[6] & 0b01000000) != 0 );
              }
#          - script.execute: safe_update_target

#      - can_id: 0x727
#       then:
#         - lambda: |-
#             ESP_LOGI("HC_Fault", "Data: %02X %02X %02X", x[0], x[1], x[2] );

      # HC_WifiDebug
#      - can_id: 0x728 
#        then:
#          - lambda: |-
#              ESP_LOGI("HC_WifiDebug", "TestStatus: %02X Wifi: %02X Wifi2: %02X", x[0], x[1], x[2] );

      # HC_Debug_IOState
      - can_id: 0x729
        then:
          - lambda: |-
              ESP_LOGI("Debug_IOState", "Data: %02X %02X %02X %02X", x[0], x[1], x[2], x[3] );

      # HC_Diag3
      - can_id: 0x78A
        then:
          - lambda: |-
              //ESP_LOGI("HC_Diag3", "Data: %02X %02X %02X %02X", x[0], x[1], x[2], x[3] );

              // Furnace Status Code
              char hex_string[6];
              sprintf(hex_string, "%02X", x[1]);
              id(furnace_status_code).publish_state(strtol(hex_string, NULL, 16));

              //id(furnace_status_code).publish_state( int16_t(x[1]) );

      # VECTOR__INDEPENDENT_SIG_MSG
#      - can_id: 0x0
#        then:
#          - logger.log:
#              format: "VECTOR__INDEPENDENT_SIG_MSG"
#              level: INFO
#number:
#  # Target tempurature from Home Assistant
#  - platform: template
#    name: "Target Temperature"
#    id: target_temperature
#    optimistic: true
#    min_value: 1.6
#    max_value: 32
#    step: 1
#    restore_value: true   # Remember after reboot
#    unit_of_measurement: °C
#    device_class: temperature
#    icon: mdi:thermometer
#    set_action:
#      then:
#        - canbus.send:
#            data: !lambda |-
#              int target_temp = x * 10;
#              uint8_t can_mesg[7];
#              can_mesg[0] = 0x01;
#              can_mesg[1] = int16_t(target_temp) & 0xff;
#              can_mesg[2] = int16_t(target_temp) >> 8 & 0xff;
#              can_mesg[3] = 0x0;
#              can_mesg[4] = 0x0;
#              can_mesg[5] = 0x0;
#              can_mesg[6] = 0x0;
#              can_mesg[7] = 0x0;
#              //ESP_LOGI("Target Set", "send can id: 0x788 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
#              return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};

binary_sensor:
  - platform: template
    name: "Pump On"
    icon: mdi:pump
    id: PumpOn_id
    entity_category: "diagnostic"

  - platform: template
    name: "Heat On"
    id: HeatOn_id
    icon: mdi:heat-wave
    entity_category: "diagnostic"

  - platform: template
    name: "Fan On"
    id: FanOn_id
    icon: mdi:fan
    entity_category: "diagnostic"

sensor:
  # wifi diagnostics
  #- platform: wifi_signal # Reports the WiFi signal strength/RSSI in dB
  #  name: "WiFi Signal dB"
  #  id: wifi_signal_db
  #  update_interval: 60s
  #  entity_category: "diagnostic"

  #- platform: copy # Reports the WiFi signal strength in %
  #  source_id: wifi_signal_db
  #  name: "WiFi Signal Strength"
  #  filters:
  #    - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
  #  unit_of_measurement: "%"
  #  entity_category: "diagnostic"

  - platform: template
    name: Ambient Temperature
    unit_of_measurement: °C
    device_class: temperature
    icon: mdi:thermometer
    id: ambient_temperature
    filters:
      - round_to_multiple_of: .5

#  - platform: template
#    name: Setpoint Temperature
#    unit_of_measurement: °C
#    device_class: temperature
#    icon: mdi:thermometer
#    id: setpoint_temperature

  - platform: template
    name: Relative Humidity
    unit_of_measurement: "%"
    device_class: humidity
    icon: mdi:water-percent
    id: relative_humidity

  # importing a Home Assistant temp sensor
#  - platform: homeassistant
#    id: temp_sensor
#    entity_id: input_number.vantemperature
#    unit_of_measurement: "°F"
#    filters:
#      - lambda: return (x-32) * 5/9; #convert to °C
#    on_value:
#      then:
#        # update rixens control with ambient temp
#        - canbus.send:
#            data: !lambda |-
#              int ambient_temp = id(temp_sensor).state * 10;
#              uint8_t can_mesg[7];
#              can_mesg[0] = 0x08;
#              can_mesg[1] = int16_t(ambient_temp) & 0xff;
#              can_mesg[2] = int16_t(ambient_temp) >> 8 & 0xff;
#              can_mesg[3] = 0x0;
#              can_mesg[4] = 0x0;
#              can_mesg[5] = 0x0;
#              can_mesg[6] = 0x0;
#              can_mesg[7] = 0x0;
#              ESP_LOGI("main", "send can id: 0x788 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
#              return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
#        - delay: 10ms
  
  # Enstead use this for temp_sensor until HA temp sensor
  #- platform: template
  #  name: Inside Temperature
  #  unit_of_measurement: °F
  #  device_class: temperature
  #  icon: mdi:thermometer
  #  id: temp_sensor

  ## Rixens's Diagnositc sensors
  # Rixens Outlet Temp
  - platform: template
    name: Glycol Outlet Temperature
    unit_of_measurement: °C
    accuracy_decimals: 0
    device_class: temperature
    icon: mdi:thermometer
    id: outlet_temp

  # Rixens Inlet Temp
  - platform: template
    name: Glycol Inlet Temperature
    unit_of_measurement: °C
    device_class: temperature
    icon: mdi:thermometer
    id: inlet_temp

  # Rixens Flame Sensor Temp
  - platform: template
    name: Flame Sensor Temperature
    unit_of_measurement: °C
    device_class: temperature
    icon: mdi:thermometer
    id: FlameSensor

  # Rixens Heater Runtime
  - platform: template
    name: Heater Runtime
    unit_of_measurement: min
    icon: mdi:fan
    id: heater_runtime
    entity_category: "diagnostic"
    
  # Rixens Heater Fan RPM
  - platform: template
    name: Heater Fan RPM
    unit_of_measurement: RPM
    icon: mdi:fan
    id: heater_fan
    entity_category: "diagnostic"
    accuracy_decimals: 0

  # Rixens Heater Glow
  - platform: template
    name: Heater Glow
    device_class: power
    unit_of_measurement: W
    icon: mdi:lightning-bolt
    id: heater_glow
    entity_category: "diagnostic"
    accuracy_decimals: 1
    filters:
      - round: 1

  # Rixens Heater Fuel
  - platform: template
    name: Heater Fuel
    device_class: frequency
    unit_of_measurement: Hz
    icon: mdi:sine-wave
    id: heater_fuel
    entity_category: "diagnostic"
    accuracy_decimals: 1
    filters:
      - round: 1

  # Rixens Voltage
  - platform: template
    name: Voltage
    device_class: voltage
    unit_of_measurement: V
    icon: mdi:lightning-bolt-outline
    id: voltage
    entity_category: "diagnostic"
    accuracy_decimals: 1
    filters:
      - round: 1

  # Rixens Furnace Status Code
  - platform: template
    name: Furnace Status Code
    icon: mdi:comment-alert
    id: furnace_status_code
    state_class: measurement
    entity_category: "diagnostic"

  # import Home Assistant sensor to override van ignition running - D+ (not necessary if you run a wire to the van's D+ ignition line)
  # this sensor controls if Rixens thinks the engine is on - it simply overrides the default D+ input (a hardwire to the ignition D+)
# JRS - Not sure the ignition running is needed if no engine heat circuit
#  - platform: homeassistant
#    id: d_plus_sensor
#    entity_id: binary_sensor.van_running
#    on_state:
#      then:
#        # tell Rixens engine is running (d+)
#        - if:
#            condition:
#              binary_sensor.is_on: d_plus_sensor
#            then:
#              - canbus.send: [0x0B, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
#              - delay: 10ms
#            else:
#              - canbus.send: [0x0B, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
#              - delay: 10ms
#        # if the engine is switched off, but climate is in heat mode or hot water is on, turn on furnace to ensure continued heating
#        - if:
#            condition:
#              or:
#                - lambda: 'return id(this_thermostat).mode == CLIMATE_MODE_HEAT;'
#                - switch.is_on: hot_water_id
#            then:
#              - switch.turn_on: furnace_id
#JRS D+ end

fan:
  # using a Speed Fan to manage the rixen's fan via a float output (below) - easier to control from Climate Thermostat and in Home Assistant if desired
  # probably not absoultely necessary, but allows you to change "internal" to "false" and have a fan entity in Home Assistant for more granular fan control
  - platform: speed
    name: Heat Blower
    output: fan_output
    id: heat_blower
    internal: True # can be set to "false" to import the fan to Home Assistant, but not really necessary with the fan speeds in the climate thermostat (below)
    speed_count: 10 # 10% 20% 30% 40% 50% 60% 70% 80% 90% 100%
    restore_mode: RESTORE_DEFAULT_OFF
    # send 0 speed to Rixens when fan is turned off
    on_turn_off:
      - logger.log:
          format: "Turn fan Heat Blower off"
          level: INFO
      - delay: 30ms
      - canbus.send: [0x02, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
      - delay: 10ms

    on_turn_on: 
      - logger.log:
          format: "Turn fan Heat Blower on - auto"
          level: INFO
      - delay: 30ms
      - canbus.send: [0x02, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
      - delay: 10ms
        
output:
  # float output targetted by the fan to send the actual values to Rixens via CAN Bus
  - platform: template
    id: fan_output
    type: float
    write_action:
      if:
        condition:
          fan.is_on: heat_blower   
        then:   
        - canbus.send:
            data: !lambda |-
              int16_t speed;
              uint8_t can_mesg[7];
              speed = id(heat_blower).speed * 10;
              can_mesg[0] = 0x02;
              can_mesg[1] = int16_t(speed) & 0xff;
              can_mesg[2] = int16_t(speed) >> 8 & 0xff;
              can_mesg[3] = 0x0;
              can_mesg[4] = 0x0;
              can_mesg[5] = 0x0;
              can_mesg[6] = 0x0;
              can_mesg[7] = 0x0;
              ESP_LOGI("main", "send can id: 0x788 hex: %x %x %x %x %x %x %x %x", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]);
              return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
        - delay: 10ms

#Blink the blue LED (for now)
#  - platform: gpio
#    pin: GPIO04
#    inverted: true
#    id: BlueLED

#  - platform: gpio
#    pin: GPIO15
#    inverted: true
#    id: GreenLED

#interval:
#  - interval: 5s
#    then:
#      - if:
#          condition:
#            - switch.is_on: hot_water_id
#          then:
#            - output.turn_on: BlueLED
#          else:
#            - output.turn_on: GreenLED
#      - delay: 500ms
#      - output.turn_off: BlueLED
#      - output.turn_off: GreenLED

climate:
  # the Thermostat for Home Assistant - NOTE: this thermostat is really only sending setpoint temperature, fan speed, and doing a bit of other logic
  # it is NOT being used for an actual hysteresis or calling for heat - that is left up to the Rixens controller
  # some settings are required by ESPHome, but practically useless in this application
  # practically speaking, "Presets" are likely more useful than "Mode". 
  # However, this is set up so that if you turn the mode to "Off", the furnace will be turned off so long as Hot Water switch is off.
  - platform: thermostat
    name: "Heat"
    id: this_thermostat
    sensor: ambient_temperature
    humidity_sensor: relative_humidity

    visual:
      temperature_step: 1.0
      min_temperature: 35 °F
      max_temperature: 90 °F

    # these are meaningless (but required) in this case - Rixen's controller is handing the actual call for heat and other hysteresis 
    min_heating_off_time: 5s
    min_heating_run_time: 5s
    min_idle_time: 5s

    target_temperature_change_action:
      - canbus.send:
          data: !lambda |-
            id(update_lock) = true;
            int target_temp = id(this_thermostat).target_temperature * 10;
            uint8_t can_mesg[7];
            can_mesg[0] = 0x01;
            can_mesg[1] = int16_t(target_temp) & 0xff;
            can_mesg[2] = int16_t(target_temp) >> 8 & 0xff;
            can_mesg[3] = 0x0;
            can_mesg[4] = 0x0;
            can_mesg[5] = 0x0;
            can_mesg[6] = 0x0;
            can_mesg[7] = 0x0;
            ESP_LOGI("main", "change action can id: 0x788 hex: %x %x %x %x %x %x %x %x temp %i", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7], target_temp);
            id(new_target_temp) = id(this_thermostat).target_temperature;
            id(update_lock) = false;
            // Block heater echoes for 2 seconds
            id(block_heater_updates_until) = millis() + 2000;
            return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};

    heat_action:
      # just a place-holder as Rixen's control box makes the actual call for heat
      - logger.log: "heat action called"
    idle_action:
      # just a place-holder as Rixen's control box makes the actual call for heat
      - logger.log: "going into idle"
    off_mode:
      # if you turn off the thermostat, and the Hot Water switch is OFF, then turn off the furnace and elctric
      - if:
          condition:
            - switch.is_off: hot_water_id
          then:
            - switch.turn_off: furnace_id
            - switch.turn_off: electric_id
    heat_mode:
      # Turn the furnace on
      - switch.turn_on: furnace_id
    
    # define presets here to use within HA
    on_boot_restore_from: memory
    # if no memory exists, will default to "Standby" preset which turns off furnace
    # Rixens doesn't seem to have supplied a CAN Bus SetProperty for Thermostat enable / dissable, so presets and furnace management are key
    default_preset: Standby
    preset:
      - name: Home
        default_target_temperature_low: 67 °F
        fan_mode: AUTO
        mode: heat
      - name: Standby
        default_target_temperature_low: 35 °F
        fan_mode: AUTO
        mode: 'OFF'
      - name: Sleep
        default_target_temperature_low: 50 °F
        fan_mode: AUTO
        mode: heat
      # Freeze Protect is probably a great place to leave your thermostat (as long as you aren't parked inside)
      # Fan is off, set point is low, and the furnace will be on (assumes you have floor heating)
      - name: Freeze Protect
        default_target_temperature_low: 40 °F
        fan_mode: 'OFF'
        mode: heat
    
    # fan modes are available in the Climate card in HA Frontend and can be called with "climate.set_fan_mode" in automations
    min_fan_mode_switching_time: 5s # required but not particularly useful in this application

    fan_mode_off_action:
      # send 0% fan command to rixens 
      - canbus.send: [0x02, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
      - delay: 10ms

    fan_mode_low_action:
      # set fan speed to 10%
      - lambda: |-
          auto call = id(heat_blower).make_call();
          call.set_speed(10);
          call.perform();
          
    fan_mode_medium_action:
      # set fan speed to 50%
      - lambda: |-
          auto call = id(heat_blower).make_call();
          call.set_speed(50);
          call.perform();

    fan_mode_high_action:
      # set fan speed to 99%
      - lambda: |-
          auto call = id(heat_blower).make_call();
          call.set_speed(99);
          call.perform();

    fan_mode_auto_action:
      # canbus auto fan command
      - canbus.send: [0x2, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
      - delay: 10ms

    on_state:
      then:
#        - lambda: |-
#            float ha_target = id(this_thermostat).target_temperature;
#
#            if (!std::isnan(ha_target)) {
#              // Only update if HA actually changed it
#              //if (fabs(id(target_setpoint) - ha_target) > 0.01) {
#              ESP_LOGI("main", "Target temp update: %f", ha_target);
#                //id(target_setpoint) = ha_target;
#                //id(apply_setpoint).execute();
#              //}
#            }

    # set target temp anytime thermostat is controlled
#    on_control:
#      - delay: 10ms
#      - logger.log:
#          format: "control action called: New %f Current %f"
#          args: [ 'id(new_target_temp)', 'id(this_thermostat).target_temperature' ]
#          level: INFO
#      - if:
#          condition:
#            lambda: 'return id(new_target_temp) != id(this_thermostat).target_temperature;'
#          then:
#            # delay to ensure target temp is set
##      - delay: 10ms
#            - canbus.send:
#                data: !lambda |-
#                  id(update_lock) = true;
#                  int target_temp = id(this_thermostat).target_temperature * 10;
#                  uint8_t can_mesg[7];
#                  can_mesg[0] = 0x01;
#                  can_mesg[1] = int16_t(target_temp) & 0xff;
#                  can_mesg[2] = int16_t(target_temp) >> 8 & 0xff;
#                  can_mesg[3] = 0x0;
#                  can_mesg[4] = 0x0;
#                  can_mesg[5] = 0x0;
#                  can_mesg[6] = 0x0;
#                  can_mesg[7] = 0x0;
#                  ESP_LOGI("main", "send can id: 0x788 hex: %x %x %x %x %x %x %x %x temp %i", can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7], target_temp);
#                  id(new_target_temp) = id(this_thermostat).target_temperature;
#                  id(update_lock) = false;
#                  return {can_mesg[0], can_mesg[1], can_mesg[2], can_mesg[3], can_mesg[4], can_mesg[5], can_mesg[6], can_mesg[7]};
#            - delay: 10ms

#    on_state:
#      - logger.log: "on_state thermostat action called"
      # update fan mode to auto on state change if it's supposed to be on auto
##      - if:
##          condition:
##            lambda: 'return id(this_thermostat).fan_mode == CLIMATE_FAN_AUTO;'
##          then:
##            - canbus.send: [0x2, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]

switch:
  # Continuous Hot Water
  - platform: template
    name: Hot Water
    id: hot_water_id
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    icon: mdi:water-thermometer
    on_turn_on:
      - logger.log:
          format: "Turn Continuous Hot Water on"
          level: INFO
      - canbus.send: [0x06, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
      - if:
          # turn on furnace if engine is off
          condition:
#jrs            and:
              - switch.is_off: furnace_id
#jrs              - binary_sensor.is_off: d_plus_sensor
          then:
            - switch.turn_on: furnace_id
    on_turn_off:
      - logger.log:
          format: "Turn Continuous Hot Water off"
          level: INFO
      - canbus.send: [0x06, 0x00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
      # When Hot Water switch is turned off: If climate Mode is Off or Preset is Standby, then turn off furnace
#c-remove#      - if:
#c-remove#          condition:
#c-remove#            or:
#c-remove#              - lambda: |-
#c-remove#                  return id(this_thermostat).mode == CLIMATE_MODE_OFF;
#c-remove#              - lambda: |-
#c-remove#                  return id(this_thermostat).custom_preset == "Standby";
#c-remove#          then:
#c-remove#            - switch.turn_off: furnace_id


  # Enable Thermostat property does not seem to be able to be set via CAN Bus at the moment
  # - platform: template
  #   name: Thermostat Enable
  #   id: thermostat_enable_id
  #   optimistic: True
  #   internal: False
  #   restore_mode: RESTORE_DEFAULT_OFF
  #   icon: mdi:power
  #   on_turn_on:
  #     - logger.log:
  #         format: "Enable Thermostat on"
  #         level: INFO
  #     - canbus.send:
  #         data: [0x0C, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
  #   on_turn_off:
  #     - logger.log:
  #         format: "Enable Thermostat off"
  #         level: INFO
  #     - canbus.send:
  #         data: [0x0C, 0x00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]

  # Heat source - Furnace
  - platform: template
    name: Furnace
    id: furnace_id
    icon: mdi:fire
    optimistic: false
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - logger.log:
          format: "Turn furnace heat on"
          level: INFO
      - canbus.send: [0x03, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
#      - delay: 10ms

    turn_off_action:
      - logger.log:
          format: "Turn furnace heat off"
          level: INFO
      - canbus.send: [0x03, 0x00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
#      - delay: 10ms

  # Heat source - Electric
  - platform: template
    name: Electric
    id: electric_id
    icon: mdi:flash
    optimistic: false
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - logger.log:
          format: "Turn electric heat on"
          level: INFO
      - canbus.send: [0x04, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
#      - delay: 10ms
    turn_off_action:
      - logger.log:
          format: "Turn electric heat off"
          level: INFO
      - canbus.send: [0x04, 0x00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]
#      - delay: 10ms

button:
  - platform: restart
    name: "Restart"
    id: restart_button
    entity_category: config

  - platform: factory_reset
    name: "Factory Reset"
    id: reset
    entity_category: config

  - platform: safe_mode
    name: "Safe Mode"
    internal: false
    entity_category: config

